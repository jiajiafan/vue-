<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<style>
		*{line-height:20px;}
		div{font-weight: 700}
		p{padding-left:24px;font-size:12px;}
	</style>
</head>
<body>
	<br>
		<div>一、var/let/const区别</div>
		<p>1).let/const定义的变量和常量只能在其所在的块级作用域内访问；<br>
		   2).let/const没有变量提升，在声明之前存在一个死区，在死区内操作let或者const定义的变量或常量会报错，所以只能先声明后访问，var存在变量提升
		   <br>
		   3).let和const不能在相同作用域内重复声明，否则会报错，var可以<br>
		   4).let和var定义的是一个变量，const定义的是一个只读常量,一旦声明，就不能改变，所以const声明和赋值必须一句话完成，只声明一个常量会报错，本质上是变量指向的那个内存地址保存的数据不能改变，对于引用数据类型只是保存的那个指针不能改变，已经定义的引用数据类型值也是可以改变的，
           5).var定义的全局变量默认也是window的属性，通过window.是可以访问的，let和const定义的全局变量，通过window.不能访问
		</p>
		<div>二、解构赋值</div>
		<p>任何数据除了null和undefined都可以结构赋值，函数的参数也可以解构赋值，解构不成功，变量的值=undefined,</p>
		<p>1.对象的结构赋值注意点：a.如果将一个已经声明的变量用于解构赋值，必须非常小心，不能把{}放在首行；b.解构赋值允许等号左边的模式之中，不放置任何变量名；c.由于数组本质是特殊的对象，因此可以对数组进行对象的解构赋值</p>
		<p>2.不能使用（）的情况：a.变量声明语句；b.函数参数；c.赋值语句的模式；可以使用（）的情况：赋值语句的非模式部分</p>
		<p>3.变量的解构赋值的用途：a.交换变量的值；b.从函数返回多个值；c.函数参数的定义（方便把一组参数与变量名对应起来）d.提取json数据；e.函数参数的默认值；f.遍历Map结构；g.输入模块的指定方法</p>
		<div>三、字符串的方法</div>
		<p>es5方法：</p>
		<p> 1）charAt(index) 通过下标找到目标小字符串<br>
		    2）charCodeAt(index) 通过下标找到汉字的ASCII值<br>
		    3) indexOf(string[,fromindex) 从前往后找通过字符串找到对应的下标<br>
		       lastIndexOf(string) 从后往前找通过字符串找到对应的下标<br>
			4) str.substr(n,m) 从索引n开始截取m个<br>
			   str.substring(n,m) 从索引n开始截取到索引m，包前不包后<br>
		       str.slice(n,m) 和substring用法一样，不同是参数可以是负数 <br>
			5) str.split(“字符”) 按照指定字符切分成n个字符串<br>
			6) str.toUpperCase() 转成大写<br>
			7) str.toLowerCase() 转成小写<br>
		    8）str.match()<br>
		    9) str.replace()<br>
		    10) str.seach()与indexOf类似，参数可以是正则</p>
		    <p>ES6方法</p>
		    <!-- unicode表示法 -->
		    <p>11）includes()返回布尔值，表示是否找到了参数字符串<br>
		    12)startsWith()返回布尔值，表示参数字符串是否在原字符串的头部<br>
		    13）endsWith()返回布尔值，表示参数字符串是否在原字符串的尾部<br>
		     以上三个方法都支持第二个参数，表示开始搜索的位置<br>
		    14）repeat()返回一个新字符串，表示将原字符串重复n次，参数先转化成Number,NaN等同于0；小数会向下取整；0--1视为0<br>
		    15）matchAll()返回一个正则表达式在当前字符串的所有匹配</p>
		     <p>ES8(2017)</p>
		     <p>
		    <p>16）padStart()在头部补全字符串到指定长度<br>
		    17) padEnd()在尾部补全字符串到指定长度</p>
		     <p>ES(2019)</p>
		    <p>18）trimStart() 返回新字符串<br>
		    19) trimEnd()返回新字符串</p>
		  <div>四、for..of、for...in和for...区别</div>
  		  <p>1.for...in返回的是键名，for...of返回的是键值</p>
		  <p>2.for...of循环调用遍历器接口(数组的遍历器接口只返回具有数字索引的属性),of可以识别大于oxffff的码点</p>
		  <div>四. ...用法</div>
		  <p>1）展开运算符，剩余运算符</p>
		  <p>2）合并数组；合并对象</p>
		  <p>3）展开数组，展开对象</p>
		  <div>六、正则的扩展</div>
		  <p>1.构造函数 new RegExp('字符串/正则'，'修饰符')<br
		  	//.flags返回所有修饰符
		  </p>
		  <p>2.字符串的四个正则方法全部定义在正则对象上</p>
		  <p>3.修饰符u/y/s分别表示unicode模式、粘连修饰符、dotAll模式；分别有对应的方法可以检测是否添加了该修饰符</p>
		  <p>es2018</p>
		  <p>1.引入行后断言和行后否定断言<?<=><?<!></p>
		  <p>2.\p{}</p>
		  <p>3.具名匹配，从groups对象上取值，配合解构赋值非常好用</p>
		  <p>新提案 matchAll方法</p>
		  <div>七、数值的扩展</div>
		  <p>1.二进制和八进制新写法</p>
		  <p>2.Number.isFinite(),和Number.isNaN()，注意和isNaN()区别</p>
		  <p>3.把全局的parseInt(),parseFloat(）移植到了Number上，使语言逐步模块化</p>
		  <p>4.Number.isInteger()判断是否是一个整数，数据精度要求高时不建议使用......还有很多方法</p>
		  <p>5、Math对象的扩展：es6新增了17个方法：<br>
             1)Math.trunc()去除小数部分，返回整数
             2）Math.sign()判断一个数是正数、负数、还是0
             3)其他都太难了，不写了
		  </p>
		  <div>八、函数的扩展</div>
		  <p>1.参数设置默认值（惰性求值）；,一般放在尾参数，结合结构赋值使用;应用：利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误（默认值设置为一个参数执行）<br>
		  1）函数length属性特点：设置默认值的参数不计数，有默认值参数后边的参数不计数，rest参数不计数
		  </p>
		  <p>2.rest参数</p>
		  <p>3.严格模式：函数参数使用了默认参数、解构赋值、reset参数就不能在函数体内显式设置严格模式,否则会报错；可有两种解决方式：1，全局下设置严格模式；2.放在一个无参数立即执行函数，内置use strict;</p>
		  <p>4.name属性，返回函数名；之前有，es写入标准的<br>
		  	匿名函数赋值给一个变量，es5和es6分别返回‘’和变量名；；；；构造函数实例，name属性为anonymous（匿名）；；；；；bind返回的函数，name属性值会加上bound前缀
		  </p>
		  <p>5.箭头函数：常用作简化回调函数；还可以让setTimeout里边的this,绑定定义时的作用域，而不是运行时的；rest参数与箭头函数结合</p>
		  <p>6.Function.protoype.toString()返回源代码，之前会省略注释和空格函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>
		  <p>7.try...catch..catch可以省略参数（2019版ES）</p>
		  <p>8.函数参数的尾逗号，（ES2017）</p>
		  <div>九、箭头函数与普通函数的区别</div>
		  <p>1.箭头函数内的this指向定义时所在的对象，而不是使用时的调用对象</p>
		  <p>2.不可以当做构造函数，否则会报错</p>
		  <p>3.没有arguments对象，可以使用rest参数代替</p>
		  <p>4.不可以使用yield命令，因此不能用作generator函数</p>
		  <p>箭头函数的优点：可以让this指向固定化，利于封装回调函数</p>
		  <p>箭头函数不适用场景：1.定义对象的方法，且该方法内部包括this；2.事件绑定的时候</p>
		  <div>十、箭头函数一般用作什么</div>
		  <p>1.回调函数</p>
		  <p>2.嵌套函数</p>
		  <div>十一、尾递归</div>
		  <p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。只在严格模式下生效；可以优化</p>
		  <p>递归会造成调用栈太多，造成溢出，尾递归的优化原理是减少调用栈，在没有条件使用尾递归时可以采用循环来模拟尾递归</p>
		  <p>蹦床函数不是真正的尾递归优化</p>
		  <div>十三、数组的扩展</div>
		  <p>push/pop/shift/unshift/splice/sort/reverse/toString以上为原有数组发生变化的的<br>
		  	join,slice,concat,indexOf,lastIndexOf,map,replace,forEach,filter<br>
		  	es新增copyWithin,find,findIndex,fill，entries,keys,values,includes,flat,flatMap
		  	,<br>
		  	其中改变原有数组的有copyWith,fill,
		  </p>

		  <div>es6</div>
		  <p>1.Array.from(具有length的对象,map方法，this指向)</p>
		  <p>2.Array.of()将一组值转成数组</p>
		  <p>3.实例上的方法 [].copyWithin(target[,start[,end)</p>
		  <p>4.实例上的fill方法，用于空数组的初始化非常方便，添加的对象是浅拷贝</p>
		  <p>5.实例上的flat/flatMap(，this)</p>
		  <p>6.es6明确规定将空值转为undefined</p>
		  <div>十四、includes与indexOf的区别</div>
		  <p>includes更语义化，返回结果是Boolen更直观，indexOf内部采用（===）严格比较，会对NaN造成误判</p>
		  <div>十五、Map和Set数据结构的has方法与includes区别</div>
		  <p>Map的是用来查找key的，Set的是用来查找value的</p>
		  <div>十六、对象的扩展</div>
		  <p>1.属性名表达式与简介表示法不能同时使用</p>
		  <p>2.super关键字，总是指向当前对象的原型对象</p>
		  <div>十七、es6遍历对象属性的方式</div>
		  <p>1)for..in(不含symbol属性)for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）</p>
		  <p>2）Object.keys(obj)返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p>
		  <p>3)Object.getOwnPropertyNames(obj)返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键</p>
		  <p>4）Object.getOwnPropertySymbols(obj)返回一个数组，包含对象自身的所有 Symbol 属性的键名</p>
		  <p>5）Reflect.ownKeys(obj)返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p>
		  <div>es6（import exports）静态模块 es7支持动态模块</div>
		  <p>commomjs require module.exports动态模块</p>
		  <div>十八、对象的新增方法</div>
		  <p>1.Object.is()</p>
		  <p>2.Object.assign(）不会赋值取值函数；<br>
		  常见用途：1）为对象添加属性；2）为对象添加方法；3）克隆对象；4）合并多个对象；5）为属性指定默认值</p>
		  <p>3.Object.getOwnPropertyDescriptors()</p>
		  <p>4.__proto__属性，Object.setPrototypeOf(),Object.getPrototypeOf()</p>
		  <p>5.Object.keys(),Object.values()，Object.entries()</p>
		  <p>6.Object.fromEntries()</p>
		  <div>十九、set的方法</div>
		  <p>1.原型方法size；返回成员总数</p>
		  <p>2.实例方法：<br>1)add(返回set本身)；<br>delete(删除某个值，返回布尔)；<br>3)has(返回布尔值)；<br>4)clear(清空所有成员)<br>5)keys;<br>6)values;<br>7)entries<br>8)forEach
		  <div>二十、generator用途</div>
		  <p>1.异步操作的同步化表达</p>
		  <div>21、promise优缺点？</div>
		  <p>优点：解决异步并发问题，promise.all;链式调用</p>
		  <p>缺点：还是基于回调，promise无法终止</p>
		  <div></div>
</script>
</html>